//
// ServiceEntity.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation
#if canImport(AnyCodable)
import AnyCodable
#endif

public struct ServiceEntity: Codable, Hashable {

    public enum ModelType: String, Codable, CaseIterable {
        case vpn = "vpn"
        case proxy = "proxy"
    }
    /** ID of the service */
    public var id: String
    /** Name of the service */
    public var name: String
    /** Type of the service */
    public var type: ModelType
    /** Per minute Cost of the service */
    public var cost: String
    /** Amount of pre-paid minutes for first payment */
    public var firstPrePaidMinutes: Double?
    /** Number of verifications needed for first payment */
    public var firstVerificationsNeeded: Double?
    /** Amount of pre-paid minutes for subsequent payments */
    public var subsequentPrePaidMinutes: Double?
    /** Number of verifications needed for subsequent payments */
    public var subsequentVerificationsNeeded: Double?
    /** Whether or not refunds are allowed */
    public var allowRefunds: Bool?
    /** Service download speed in Mbits */
    public var downloadSpeed: Double
    /** Service upload speed in Mbits */
    public var uploadSpeed: Double
    /** array containing Proxy related settings. only available if service is of type proxy, null otherwise */
    public var proxy: [ProxySettingsEntity]?
    /** array containing VPN related settings. only available if service is of type vpn, null otherwise */
    public var vpn: [VpnSettingsEntity]?
    public var validity: TimeRangeEntity?
    /** disable or not the service */
    public var disable: Bool
    /** inside each service, there should be a field named certificates that has a list of IDs, referencing the certificates at the provider level. */
    public var certificates: [CertificatesEntity]?

    public init(id: String, name: String, type: ModelType, cost: String, firstPrePaidMinutes: Double? = nil, firstVerificationsNeeded: Double? = nil, subsequentPrePaidMinutes: Double? = nil, subsequentVerificationsNeeded: Double? = nil, allowRefunds: Bool? = nil, downloadSpeed: Double, uploadSpeed: Double, proxy: [ProxySettingsEntity]? = nil, vpn: [VpnSettingsEntity]? = nil, validity: TimeRangeEntity? = nil, disable: Bool, certificates: [CertificatesEntity]? = nil) {
        self.id = id
        self.name = name
        self.type = type
        self.cost = cost
        self.firstPrePaidMinutes = firstPrePaidMinutes
        self.firstVerificationsNeeded = firstVerificationsNeeded
        self.subsequentPrePaidMinutes = subsequentPrePaidMinutes
        self.subsequentVerificationsNeeded = subsequentVerificationsNeeded
        self.allowRefunds = allowRefunds
        self.downloadSpeed = downloadSpeed
        self.uploadSpeed = uploadSpeed
        self.proxy = proxy
        self.vpn = vpn
        self.validity = validity
        self.disable = disable
        self.certificates = certificates
    }

    public enum CodingKeys: String, CodingKey, CaseIterable {
        case id
        case name
        case type
        case cost
        case firstPrePaidMinutes
        case firstVerificationsNeeded
        case subsequentPrePaidMinutes
        case subsequentVerificationsNeeded
        case allowRefunds
        case downloadSpeed
        case uploadSpeed
        case proxy
        case vpn
        case validity
        case disable
        case certificates
    }

    // Encodable protocol methods

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(id, forKey: .id)
        try container.encode(name, forKey: .name)
        try container.encode(type, forKey: .type)
        try container.encode(cost, forKey: .cost)
        try container.encodeIfPresent(firstPrePaidMinutes, forKey: .firstPrePaidMinutes)
        try container.encodeIfPresent(firstVerificationsNeeded, forKey: .firstVerificationsNeeded)
        try container.encodeIfPresent(subsequentPrePaidMinutes, forKey: .subsequentPrePaidMinutes)
        try container.encodeIfPresent(subsequentVerificationsNeeded, forKey: .subsequentVerificationsNeeded)
        try container.encodeIfPresent(allowRefunds, forKey: .allowRefunds)
        try container.encode(downloadSpeed, forKey: .downloadSpeed)
        try container.encode(uploadSpeed, forKey: .uploadSpeed)
        try container.encodeIfPresent(proxy, forKey: .proxy)
        try container.encodeIfPresent(vpn, forKey: .vpn)
        try container.encodeIfPresent(validity, forKey: .validity)
        try container.encode(disable, forKey: .disable)
        try container.encodeIfPresent(certificates, forKey: .certificates)
    }
}

